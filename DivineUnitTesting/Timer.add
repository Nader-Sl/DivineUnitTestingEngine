--[[
@author Nader Sl

A useful and rich Timer class.

*To use as a stopwatch (countdown) create the instance with a limit > 0, otherwise set
limit to 0 to monitor time elapsed
--]]
class 'TimerC'

--private fields


-- Constructor
function TimerC:__init(limit)
  self.readonly = {}
  self.readonly.limit = limit;
  self.readonly.start = os.clock()*1000
  self.readonly.paused = false
  self.readonly.pauseTime = -1
end

--Functions

function TimerC:setLimit(limit)
  self.readonly.limit = limit;
end

function TimerC:getLimit()
  return self.readonly.limit
end

function TimerC:getElapsed()
  local timeSincePause = 0;
  if self.readonly.paused then
    timeSincePause = os.clock()*1000 - self.readonly.pauseTime
  end
  return os.clock()*1000 - (self.readonly.start + timeSincePause)
end

function TimerC:getRemaining()
  return self.readonly.limit - self:getElapsed()
end

function TimerC:getRemainingPercentage()
  return (self:getRemaining()*100)/self.readonly.limit
end

function TimerC:isRunning()
  return self:getRemaining() > 0
end

function TimerC:isUp()
  return self:getRemaining() <= 0
end
function TimerC:reset()
  self.reset( self.readonly.limit)
end
function TimerC:reset(limit)
  self:setLimit(limit);
  self.readonly.start = os.clock()*1000;
end

function TimerC:pause()
  if not self.readonly.paused then
    self.readonly.paused = true;
    self.readonly.pauseTime = os.clock()*1000;
    return true
  end
  return false
end

function TimerC:resume()
  if self.readonly.paused then
    self.readonly.start = self.readonly.start + ((os.clock()*1000) - self.readonly.pauseTime)
    self.readonly.paused = false;
    return true
  end
  return false
end


function TimerC:getLimitString()
  local seconds =  self:getLimit() / 1000
  local output = ""


  local ms = self:getLimit() % 1000
  local sec = seconds
  local min = sec / 60
  local hour = min / 60
  local ttlsecond = seconds < 0 and 0 or math.floor(sec % 60)
  local ttlminute = seconds < 0 and 0 or math.floor(min % 60)
  local ttlhour = seconds < 0 and 0 or math.floor(hour)

  --  output = output..(ttlhour<10 and 0 or "")..ttlhour..":"
  output = output..(ttlminute<10 and 0 or "")..ttlminute..":"
  output = output..(ttlsecond<10 and 0 or "")..ttlsecond

  return output;
end

function TimerC:getRemainingString()
  local seconds = math.floor(self:getRemaining() / 1000)
  local output = ""


  local ms = math.floor(self:getRemaining() % 1000)
  local sec = seconds
  local min = math.floor(sec / 60)
  local hour = math.floor(min / 60)
  local ttlsecond = seconds < 0 and 0 or math.floor(sec % 60)
  local ttlminute = seconds < 0 and 0 or math.floor(min % 60)
  local ttlhour = seconds < 0 and 0 or math.floor(hour)

  --  output = output..(ttlhour<10 and 0 or "")..ttlhour..":"
  output = output..(ttlminute<10 and 0 or "")..ttlminute..":"
  output = output..(ttlsecond<10 and 0 or "")..ttlsecond

  return output;
end

function TimerC:getElapsedString()
  local seconds = math.floor(self:getElapsed() / 1000)
  local output = ""


  local ms = math.floor(self:getElapsed() % 1000)
  local sec = seconds
  local min = math.floor(sec / 60)
  local hour = math.floor(min / 60)
  local ttlsecond = seconds < 0 and 0 or math.floor(sec % 60)
  local ttlminute = seconds < 0 and 0 or math.floor(min % 60)
  local ttlhour = seconds < 0 and 0 or math.floor(hour)

  output = output..(ttlhour<10 and 0 or "")..ttlhour..":"
  output = output..(ttlminute<10 and 0 or "")..ttlminute..":"
  output = output..(ttlsecond<10 and 0 or "")..ttlsecond

  return output;
end

function TimerC:isUpThenReset()
  if self:isUp() then
    self:reset()
    return true
  end
  return false
end